(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{466:function(e,n,t){"use strict";t.r(n);var s=t(4),i=Object(s.a)({},(function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h2",{attrs:{id:"css之镂空字体"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#css之镂空字体"}},[e._v("#")]),e._v(" css之镂空字体")]),e._v(" "),t("p",[e._v("有时候，ui小姐姐设计的图是镂空字体，这就让人很头疼了，而大部分的时间内，这种字都是使用图片代替的，要进行改动又很麻烦，但是css中意外发现了属性可以实现哟，记录一下：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("html：\n  <p> Hello, world</p>\n\ncss:\n  p {\n    -webkit-text-stroke: 1px #fff; //文字描边\n    -webkit-text-fill-color: transparent;\n  }\n以上两个属性配套使用，即可生成镂空文字。\n")])])]),t("h2",{attrs:{id:"关于两个行内元素未对齐的问题"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#关于两个行内元素未对齐的问题"}},[e._v("#")]),e._v(" 关于两个行内元素未对齐的问题")]),e._v(" "),t("p",[e._v("遇到了个问题，在一排行内元素排列时，发现了未对齐的问题，还以为是属性哪里影响了，检查了很久，真的是百思不得其解。属性如下")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("div\n  display: inline-flex;\n")])])]),t("p",[e._v("本来是使用inline-block的，后来发现了这个问题，遂改成inline-flex,但是该属性在pc上可以实现，在手机上测不行。\n网上搜了一下，说问题出在没有对准基线上，修改如下")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("div\n  display: inline-block;\n  vertical-align: middle;\n")])])]),t("h2",{attrs:{id:"css换行的那些事"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#css换行的那些事"}},[e._v("#")]),e._v(" css换行的那些事")]),e._v(" "),t("ol",[t("li",[e._v("单行文本溢出，省略号显示")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("div\n    white-space: nowrap;\n    overflow: hidden;\n    text-overflow: ellipsis;\n")])])]),t("ol",{attrs:{start:"2"}},[t("li",[e._v("多行文本换行显示")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("div\n    display: -webkit-box;\n    -webkit-line-clamp: 2;\n    -webkit-box-orient: vertical;\n    overflow: hidden;\n\n注： -webkit-line-clamp: 用来设置一个块级元素内部文本显示行数，目前支持-webkit-内核，需要考虑兼容性问题，同时需要配合-webkit-其他私有属性进行配合\n")])])]),t("h2",{attrs:{id:"关于ios-input以及flex的那些事："}},[t("a",{staticClass:"header-anchor",attrs:{href:"#关于ios-input以及flex的那些事："}},[e._v("#")]),e._v(" 关于ios:input以及flex的那些事：")]),e._v(" "),t("h3",{attrs:{id:"input高度问题："}},[t("a",{staticClass:"header-anchor",attrs:{href:"#input高度问题："}},[e._v("#")]),e._v(" input高度问题：")]),e._v(" "),t("p",[e._v("很神奇的事情，在页面中使用了未设立高度，通过padding对元素高度进行支撑，在安卓手机以及pc端支持良好，但是在ios中却发现input没有了高度，百思不得其解,而后进行解决，对其使用rem对高度进行设置，然而并不是很好用,经过网上查询，需要使用line-height对行高进行设置，从而解决input的设置高度无效问题;")]),e._v(" "),t("h3",{attrs:{id:"ios-display-flex-高度塌陷"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#ios-display-flex-高度塌陷"}},[e._v("#")]),e._v(" ios display:flex 高度塌陷")]),e._v(" "),t("p",[e._v("在父元素上设置了flex,未设置高度，高度由子元素进行填充，在安卓上展示良好，在ios则是出现了高度塌陷的问题，之前在另一个页面上也运用了，但是没有出现问题，\n例子如下：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v(".parent {\n  padding: 1.25rem;\n  display: flex;\n  justify-content: space-between;\n}\n.child {\n  width: 43%;\n  text-align: center;\n  padding: 1.25rem 0;\n  border-radius: 8px;\n  color: #fff;\n  font-size: 1.4rem;\n  line-height: 2rem;\n}\n")])])]),t("p",[e._v("关于这个问题，网上似乎比较少，但好歹还是找到了，其中有这么一个属性：flex-shrink;\nflex-shrink: 用来指明flex元素的收缩规则，当flex盒子空间不足时进行收缩，默认值为1,以对应的flex-shrink值进行收缩，负值无效，而当flex-shrink为0的时候则是不进行收缩，了解一下关于flex-shrink的计算方法：\n计算：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("  .parent {\n    width: 300px;\n    display: flex;\n    padding: 15px;\n  }\n  .child1 {\n    width: 60%;\n    flex-shrink: 1;\n  }\n  .child2 {\n    width: 60%;\n    flex-shrink: 2;\n  }\n  此时，两个子元素的宽度和超出父元素，产生收缩，基本：flexType - flexShrink * flexbase;\n  需要明确一点就是，计算flex父元素收缩时内容是不包括padding,marging,border等部分的。\n  即当前需要收缩的内容：flexContent = 270*20% = 54;\n  基础收缩量： 54 / (1+2) = 18;\n  .child1 : 270*0.6 - 18\n  .child2: (270*.6) - (18*2)")])])])])}),[],!1,null,null,null);n.default=i.exports}}]);